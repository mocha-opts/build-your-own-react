See also [Scrollycoding](/scrollycoding) and [Spotlight](/spotlight).

Step I: The createElement Function

Step II: The render Function

Step III: Concurrent Mode

Step IV: Fibers

Step V: Render and Commit Phases

Step VI: Reconciliation

Step VII: Function Components

Step VIII: Hooks

<CH.Scrollycoding>

## ç¬¬é›¶æ­¥ï¼šå›é¡¾ JSX to JS

```js app.js focus=1:3
const element = <h1 title="foo">Hello</h1>;
const container = document.getElementById("root");
ReactDOM.render(element, container);
```

é¦–å…ˆæˆ‘ä»¬å…ˆé€šè¿‡ä»¥ä¸‹ä¸‰è¡Œä»£ç æ¥å›é¡¾ä¸€äº› React ä¸­çš„åŸºæœ¬æ¦‚å¿µã€‚

ç¬¬ä¸€è¡Œä»£ç **å®šä¹‰äº†ä¸€ä¸ª React å…ƒç´ **ã€‚

ç¬¬äºŒè¡Œä»£ç ä» DOM ä¸­ **è·å–äº† id ä¸º root çš„å…ƒç´ **ã€‚

ç¬¬ä¸‰è¡Œä»£ç å°† **å®šä¹‰çš„ React å…ƒç´ ** æ¸²æŸ“åˆ° **è·å–åˆ°çš„å…ƒç´ ä¸­**å»ã€‚

ä»¥ä¸Šä¸‰è¡Œä»£ç å°±æ„æˆäº†ä¸€ä¸ªéå¸¸ç®€å•çš„ React Appï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•é€šè¿‡åŸç”Ÿçš„ JS æ¥ä»£æ›¿ä»¥ä¸Šä¸‰è¡Œä»£ç ã€‚

---

```js app.js focus=1

```

å…ˆæ¥çœ‹çœ‹ç¬¬ä¸€è¡Œä»£ç ï¼Œå…¶ä¸­çš„ React å…ƒç´ å°±æ˜¯é€šè¿‡ js æ¥å®šä¹‰çš„ï¼Œå®ƒç”šè‡³ä¸æ˜¯åˆæ³•çš„ JS è¯­æ³•ï¼Œä¸ºäº†ç”¨åŸç”Ÿçš„ JS æ¥æ›¿ä»£å®ƒï¼Œé¦–å…ˆæˆ‘ä»¬å¾—è®©å®ƒå˜å¾—åˆæ³•ã€‚

JSX åˆ° JS åˆ°è½¬æ¢æ˜¯é€šè¿‡åƒ Babel è¿™æ ·çš„å·¥å…·æ¥å®ç°çš„ï¼Œè½¬æ¢è¿‡ç¨‹æ¯”è¾ƒç®€å•ï¼šæŠŠ js è¯­æ³•ä¸­çš„æ ‡ç­¾ tagã€å±æ€§ propsã€å­å…ƒç´  children ä½œä¸ºå‚æ•°ä¼ å…¥ä¸€ä¸ªå«åš createElement çš„å‡½æ•°æ¥å¤„ç†ã€‚

---

```js app.js focus=1:7
const element = {
  type: "h1",
  props: {
    title: "foo",
    children: "Hello",
  },
};

const container = document.getElementById("root");
ReactDOM.render(element, container);
```

React.createElement è¿™ä¸ªæ–¹æ³•é€šè¿‡ä¼ å…¥çš„å‚æ•°åˆ›å»ºäº†ä¸€ä¸ªå¯¹è±¡ã€‚æŠ›å¼€è¿™ä¸ªæ–¹æ³•ä¼šå¯¹å‚æ•°çš„ä¸€äº›éªŒè¯ä»¥å¤–ï¼Œè¿™å°±æ˜¯å®ƒæ‰€åšçš„å…¨éƒ¨äº‹æƒ…ã€‚ä»¥æ­¤ä¸ºåŸºç¡€ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç®€å•æ¨¡ä»¿ä¸€ä¸‹ React.createElement åˆ›å»ºçš„å¯¹è±¡ã€‚

æˆ‘ä»¬æ‰€å®šä¹‰çš„å…ƒç´ æ˜¯ä¸€ä¸ªå…·æœ‰ä¸¤ä¸ªå±æ€§ï¼ˆtype å’Œ propsï¼‰çš„å¯¹è±¡ï¼ˆå½“ç„¶çœŸæ­£çš„ ReactElement å¯ä¸æ­¢è¿™ä¸¤ä¸ªå±æ€§ï¼Œä¸è¿‡åœ¨è¿™é‡Œæˆ‘ä»¬åªå…³å¿ƒè¿™ä¸¤ä¸ªï¼‰ã€‚

type æŒ‡çš„æ˜¯æˆ‘ä»¬æƒ³è¦åˆ›å»ºçš„ DOM å…ƒç´ ç±»å‹çš„å­—ç¬¦ä¸²ï¼Œç­‰åŒäºé€šè¿‡ document.createElement æ–¹æ³•æ¥åˆ›å»º DOM å…ƒç´ æ—¶ä¼ å…¥çš„ tagNameã€‚type ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä½†æ˜¯ä¸ºäº†ä¸é€ æˆå›°æƒ‘ï¼Œè¿™ä¸ªç­‰åˆ°ç¬¬ä¸ƒæ­¥æ—¶æˆ‘ä»¬å†è¯´ã€‚

props ä¹Ÿæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒå­˜æ”¾çš„æ˜¯ JSX ä¸­è®¾ç½®çš„ç‰¹æ€§ï¼ˆattributesï¼‰çš„é”®ä¸å€¼ï¼Œä»¥åŠä¸€ä¸ªç‰¹æ®Šçš„å±æ€§ï¼ˆpropertyï¼‰childrenã€‚

children åœ¨è¿™é‡Œæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¸è¿‡æ›´å¤šæ—¶å€™å®ƒä¼šæ˜¯ä¸€ä¸ªåŒ…å«è®¸å¤šå…ƒç´ çš„æ•°ç»„ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆä¼—å¤šçš„å…ƒç´ é€šè¿‡é”™ç»¼å¤æ‚çš„å…³ç³»èƒ½å¤Ÿæ„å»ºæˆæ ‘çš„åŸå› ã€‚

---

```js app.js focus=10

```

å¦å¤–æˆ‘ä»¬éœ€è¦æ¥å¤„ç†çš„ä¸€ä¸ªæ–¹æ³•æ˜¯ ReactDOM.renderã€‚render æ˜¯ React æ¥æ”¹å˜ DOM çš„æ–¹æ³•ï¼Œè¿™æ ·ç®€å•çš„ä¸€å¥æè¿°æœ‰äº›è¿‡äºå®½æ³›äº†ï¼Œä¸è¿‡æˆ‘ä»¬å…ˆå¯ä»¥æ ¹æ®è¿™ç‚¹æ¥è¯•ç€æ£é¼“æ£é¼“å®ƒæ˜¯æ€ä¹ˆæ”¹å˜ DOM çš„ã€‚

---

```js app.js  focus=1,2,4,7,11,12
const element = {
  type: "h1",
  props: {
    title: "foo",
    children: "Hello",
  },
};
â€‹
const container = document.getElementById("root")
â€‹
const node = document.createElement(element.type)
node["title"] = element.props.title
â€‹
const text = document.createTextNode("")
text["nodeValue"] = element.props.children
â€‹
node.appendChild(text)
container.appendChild(node)
```

é¦–å…ˆæˆ‘ä»¬æ ¹æ®æˆ‘ä»¬åˆ›å»ºçš„ element çš„å±æ€§ type æ¥åˆ›å»ºå¯¹åº”çš„ DOM èŠ‚ç‚¹ï¼Œåœ¨è¿™é‡Œæ˜¯ h1ã€‚ç„¶åæˆ‘ä»¬æ ¹æ®å…ƒç´  element çš„å±æ€§ä¸ºåˆ›å»ºçš„èŠ‚ç‚¹è®¾ç½®å±æ€§ï¼Œåœ¨è¿™é‡Œæ˜¯ titleã€‚

ä¸ºäº†é¿å…å›°æ‰°ï¼Œåœ¨è¿™é‡Œè¯´æ˜ä¸€ä¸‹ï¼Œæ–‡ä¸­æ‰€è¯´çš„å…ƒç´ æŒ‡çš„æ˜¯ React Elementï¼ŒèŠ‚ç‚¹æŒ‡çš„æ˜¯ DOM Elementï¼Œä»¥æ­¤æ¥åŒºåˆ†ä¸¤è€…ã€‚

---

```js app.js  focus=1,2,5,7,14,15

```

ç„¶åæˆ‘ä»¬æ¥ä¸ºå­å…ƒç´ åˆ›å»ºç›¸åº”çš„èŠ‚ç‚¹ã€‚è¿™é‡Œçš„è¯åªæœ‰ä¸€ä¸ªå­å…ƒç´ ï¼Œä¸ºæ­¤æˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹ã€‚ä¹‹æ‰€ä»¥é€‰æ‹©åˆ›å»ºæ–‡æœ¬èŠ‚ç‚¹ï¼ˆtextNodeï¼‰è€Œä¸æ˜¯è®¾ç½® innerText å±æ€§ï¼Œæ˜¯å› ä¸ºè¿™æ ·åšçš„è¯ä¹‹åæˆ‘ä»¬èƒ½å¤Ÿé€šè¿‡åŒä¸€ç§æ–¹å¼æ¥å¤„ç†æ‰€æœ‰å…ƒç´ ã€‚

åŒæ—¶éœ€è¦æ³¨æ„ï¼Œæˆ‘ä»¬åœ¨ä¸ºèŠ‚ç‚¹è®¾ç½® nodeValue å±æ€§çš„è¿™ä¸ªè¿‡ç¨‹ï¼Œä¸è®¾ç½®èŠ‚ç‚¹ h1 è®¾ç½® title å±æ€§ç±»ä¼¼ï¼Œå°±åƒæ˜¯åœ¨è®¾ç½®ä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹çš„ nodeValue ä¸º Helloï¼Œå³ `props: {nodeValue: "hello"}`ã€‚

---

```js app.js  focus=9,17,18

```

æœ€åï¼Œæˆ‘ä»¬å°†åˆ›å»ºçš„æ–‡æœ¬èŠ‚ç‚¹æ”¾åˆ°èŠ‚ç‚¹ h1 ä¸Šï¼Œå°†èŠ‚ç‚¹ h1 æ”¾åˆ° id ä¸º root çš„èŠ‚ç‚¹ä¸Šå»ã€‚

---

åˆ°æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬å°±å®Œæˆäº†ç”¨åŸç”Ÿçš„ JS æ¥æ›¿ä»£ JSX è¯­æ³•è¿™ä¸€ç›®æ ‡ï¼Œå®Œæ•´çš„ä»£ç å¦‚ä¸‹ï¼š

```js app.js

```

---

</CH.Scrollycoding>

---

<CH.Scrollycoding>

## ç¬¬ä¸€æ­¥ï¼šcreateElement

```js
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
);
const container = document.getElementById("root");
ReactDOM.render(element, container);
```

è®©æˆ‘ä»¬ä»å¦å¤–ä¸€ä¸ª React App å¼€å§‹ã€‚è¿™æ¬¡ï¼Œæˆ‘ä»¬æ¥å°è¯•åˆ›å»ºä¸€ä¸ªè‡ªå·±çš„ React æ¥æ›¿ä»£çœŸæ­£çš„ Reactã€‚

ä»å®ç° createElement æ–¹æ³•å¼€å§‹å§ã€‚

é¦–å…ˆï¼Œåœ¨ JSX è½¬æ¢åˆ° JS çš„è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ createElement` è¿™ä¸ªæ–¹æ³•åˆ°åº•éƒ½åšäº†äº›ä»€ä¹ˆå§ã€‚

---

```js focus=1:6
const element = React.createElement(
  "div",
  { id: "foo" },
  React.createElement("a", null, "bar"),
  React.createElement("b")
);
const container = document.getElementById("root");
ReactDOM.render(element, container);
```

åœ¨å‰é¢æˆ‘ä»¬æåˆ°è¿‡ï¼Œä¸€ä¸ªå…ƒç´ ï¼ˆæˆ‘ä»¬ç®€åŒ–è¿‡çš„ï¼‰å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªå¸¦æœ‰ type å’Œ props è¿™ä¸¤ä¸ªå±æ€§çš„å¯¹è±¡ã€‚æˆ‘ä»¬çš„æ–¹æ³•å”¯ä¸€éœ€è¦æ“å¿ƒçš„å°±æ˜¯å¦‚ä½•å»åˆ›å»ºè¿™ä¸ªå¯¹è±¡ã€‚

---

```js focus=1:9
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children,
    },
  }
}
â€‹
const element = React.createElement(
  "div",
  { id: "foo" },
  React.createElement("a", null, "bar"),
  React.createElement("b")
)
const container = document.getElementById("root")
ReactDOM.render(element, container)
```

åœ¨ä»¥ä¸Šä»£ç ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨å±•å¼€æ“ä½œç¬¦... æ¥å¤„ç† propsï¼Œä½¿ç”¨å‰©ä½™å‚æ•°è¯­æ³•...ï¼ˆæ²¡é”™ï¼Œè¿˜æ˜¯è¿™ä¸‰ä¸ªç‚¹ï¼Œéƒ½æ˜¯ ES6 è¯­æ³•ï¼‰æ¥å¤„ç† childrenï¼Œç»è¿‡å‰©ä½™å‚æ•°è¯­æ³•çš„å¤„ç†ï¼Œchildren å°±å˜æˆäº†ä¸€ä¸ªæ•°ç»„ã€‚

ä¾‹å¦‚ï¼ŒcreateElement("div") è¿”å›ï¼š

```javascript
{
type: "div",
props: { children: [] }
}
```

createElement("div", null, a) è¿”å›ï¼š

```javascript
{
type: "div",
props: { children: [a] }
}
```

createElement("div", null, a, b) è¿”å›ï¼š

```javascript
{
type: "div",
props: { children: [a, b] }
}
```

---

```js focus=6:10,15:23
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
const element = React.createElement(
  "div",
  { id: "foo" },
  React.createElement("a", null, "bar"),
  React.createElement("b")
)
const container = document.getElementById("root")
ReactDOM.render(element, container)
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œchildren æ•°ç»„ä¸­çš„å…ƒç´ ä¸ä¸€å®šæ˜¯å¯¹è±¡ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯åŸå§‹ç±»å‹çš„å€¼å¦‚ number æˆ– stringã€‚å¯¹äºè¿™ç§å…ƒç´ ï¼Œæˆ‘ä»¬éœ€è¦å°è£…æˆä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ä¸ºå…¶åˆ›å»ºä¸€ç§ç‰¹æ®Šçš„ typeï¼šTEXT_ELEMENTã€‚

éœ€è¦æ³¨æ„çœŸæ­£çš„ React å¹¶æ²¡æœ‰å°è£…åŸå§‹ç±»å‹çš„å€¼æˆ–åœ¨æ²¡æœ‰ children æ—¶åˆ›å»ºä¸€ä¸ªç©ºæ•°ç»„ï¼Œæˆ‘ä»¬è¿™æ ·åšæ˜¯ä¸ºäº†ç®€åŒ–æˆ‘ä»¬çš„ä»£ç ï¼Œå› ä¸ºæˆ‘ä»¬çš„ç›®æ ‡æ˜¯æ˜“äºç†è§£ï¼Œè€Œä¸æ˜¯è¿½æ±‚é«˜æ€§èƒ½ã€‚

---

```js focus=25,28:30
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
const element = React.createElement(
  "div",
  { id: "foo" },
  React.createElement("a", null, "bar"),
  React.createElement("b")
)
const container = document.getElementById("root")
ReactDOM.render(element, container)
```

åˆ°æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰æ›¿æ¢ React.createElement è¿™ä¸ªæ–¹æ³•

æ›¿æ¢ React çš„ç¬¬ä¸€æ­¥ï¼Œç»™æˆ‘ä»¬çš„åº“å–ä¸ªåå­—å§ ğŸ¤¨ã€‚

åå­—è¦å¬èµ·æ¥åƒ ReactğŸ¤”ï¼ŒåŒæ—¶ä¹Ÿè¦æœ‰æ•™å­¦ï¼ˆ_didactic_ï¼‰çš„å‘³é“ ğŸ§ã€‚

---

æœ‰äº† ğŸ’¡ï¼Œå°±å«å®ƒ Didact å§ã€‚

```js focus=25:27,29,32:33
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
const Didact = {
  createElement,
}
â€‹
const element = Didact.createElement(
  "div",
  { id: "foo" },
  Didact.createElement("a", null, "bar"),
  Didact.createElement("b")
)
const container = document.getElementById("root")
ReactDOM.render(element, container)
```

ä½†æ˜¯æˆ‘ä»¬ä»ç„¶éœ€è¦ä½¿ç”¨ JSX è¯­æ³•ï¼Œæ€æ ·æ‰èƒ½è®© babel çŸ¥é“æˆ‘ä»¬ç”¨çš„æ˜¯ Didact ä¸­çš„ createElement æ–¹æ³•è€Œä¸æ˜¯ React çš„å‘¢ï¼Ÿ

---

```js focus=29:34
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
const Didact = {
  createElement,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
ReactDOM.render(element, container)
```

å¦‚æœæˆ‘ä»¬æœ‰è¿™æ ·çš„æ³¨é‡Šï¼Œå½“ Babel è½¬ä¹‰ JSX æ—¶ï¼Œå®ƒå°†ä½¿ç”¨æˆ‘ä»¬å®šä¹‰çš„å‡½æ•°ã€‚

---

## ç¬¬äºŒæ­¥ï¼šrender

```js focus=42
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
function render(element, container) {
  // TODO create dom nodes
}
â€‹
const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

æ¥ç€ï¼Œè®©æˆ‘ä»¬å…³æ³¨æœ€åä¸€è¡Œä»£ç ã€‚æ˜¯çš„æ²¡é”™ï¼Œæœ¬èŠ‚çš„ç›®æ ‡å°±æ˜¯å®ç°æˆ‘ä»¬è‡ªå·±çš„ render æ–¹æ³•ä»¥æ›¿æ¢ ReactDOM.renderã€‚

---

å¯¹äºç°åœ¨çš„æˆ‘ä»¬æ¥è¯´ï¼Œæˆ‘ä»¬åªéœ€è¦å…³å¿ƒæŠŠå…ƒç´ å˜æˆèŠ‚ç‚¹æ·»åŠ åˆ° DOM ä¸Šå»ã€‚è‡³äºæ›´æ–°å’Œåˆ é™¤ï¼Œæˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥æ¥ï¼Œåé¢å†è€ƒè™‘è¿™äº›ã€‚

```js focus=25:29,31:32,42
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
function render(element, container) {
  // TODO create dom nodes
}
â€‹
const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

å…ˆæ­å¥½äº†æ¶å­ï¼Œæ¥ç€å°±åªéœ€è¦åœ¨ render æ–¹æ³•å†…éƒ¨å»å®ç°å…·ä½“çš„åŠŸèƒ½å°±å¥½äº†ã€‚

---

é¦–å…ˆï¼Œæˆ‘ä»¬å…ˆæ ¹æ®å…ƒç´ çš„ç±»å‹ type æ¥åˆ›å»ºç›¸åº”çš„ DOM èŠ‚ç‚¹ï¼Œç„¶åå°†è¿™ä¸ªèŠ‚ç‚¹æ·»åŠ åˆ°å®¹å™¨èŠ‚ç‚¹ container ä¸­ã€‚

```js focus=25:30
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
function render(element, container) {
  const dom = document.createElement(element.type)
â€‹
  container.appendChild(dom)
}
â€‹
const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å½“ç„¶ï¼Œä¸è¦å¿˜äº†å­å…ƒç´  childrenï¼Œè¿™é‡Œé‡‡ç”¨é€’å½’çš„æ–¹æ³•æ¥å¤„ç†ã€‚

```js focus=25,27:33
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
function render(element, container) {
  const dom = document.createElement(element.type)
â€‹
  element.props.children.forEach(child =>
    render(child, dom)
  )
â€‹
  container.appendChild(dom)
}
â€‹
const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ç­‰ç­‰ï¼Œè¿˜æœ‰æ–‡æœ¬å…ƒç´ å‘¢ï¼Œå¦‚æœå…ƒç´ çš„ç±»å‹ type æ˜¯ TEXT_ELEMENTï¼Œæˆ‘ä»¬è¦ä¸ºå…¶åˆ›å»ºæ–‡æœ¬èŠ‚ç‚¹ã€‚

```js focus=26:29
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
function render(element, container) {
  const dom =
    element.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(element.type)
â€‹
  element.props.children.forEach(child =>
    render(child, dom)
  )
â€‹
  container.appendChild(dom)
}
â€‹
const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)

```

---

æœ€åï¼ŒèŠ‚ç‚¹æœ‰äº†ï¼Œå°±è¯¥ä¸ºå…¶æ·»åŠ å±æ€§ props äº†ã€‚è®°å¾—éœ€è¦æ’é™¤ props ä¸­çš„ childrenã€‚

```js focus=31:37
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}
â€‹
function render(element, container) {
  const dom =
    element.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(element.type)
â€‹
 const isProperty = key => key !== "children"
  Object.keys(element.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = element.props[name]
    })

  element.props.children.forEach(child =>
    render(child, dom)
  )
â€‹
  container.appendChild(dom)
}
â€‹
const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

ç°åœ¨æˆ‘ä»¬çš„åº“ Didact ä¹Ÿå¯ä»¥å°† JSX å…ƒç´ æ¸²æŸ“æˆçœŸæ­£çš„ DOM èŠ‚ç‚¹äº†ã€‚

ä½ ä¹Ÿå¯ä»¥åœ¨ [codesandbox](https://codesandbox.io/s/didact-2-k6rbj?file=/src/index.js:0-1113) ä¸Šçœ‹çœ‹æœ€ç»ˆçš„æ•ˆæœæ€ä¹ˆæ ·ã€‚

---

</CH.Scrollycoding>
<CH.Scrollycoding>

## ç¬¬ä¸‰æ­¥ï¼šConcurrent Mode

åœ¨å¼€å§‹å®ç°å¹¶å‘ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ¥è§£å†³ä¸€ç‚¹é—®é¢˜ã€‚

```js focus=25,38:40,43
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}

function render(element, container) {
  const dom =
    element.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(element.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(element.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = element.props[name]
    })
â€‹
  element.props.children.forEach(child =>
    render(child, dom)
  )
â€‹
  container.appendChild(dom)
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

æ³¨æ„ä»¥ä¸Šä»£ç ï¼Œå› ä¸ºé‡‡ç”¨çš„æ˜¯é€’å½’ï¼Œä¸€æ—¦æˆ‘ä»¬å¼€å§‹æ¸²æŸ“ï¼Œåœ¨æ•´ä¸ªå…ƒç´ æ ‘æ¸²æŸ“çš„è¿‡ç¨‹æ˜¯æ— æ³•åœä¸‹æ¥çš„ã€‚å¦‚æœå…ƒç´ æ ‘éå¸¸å¤æ‚çš„è¯ï¼Œå°±ä¼šå ç”¨ä¸»çº¿ç¨‹éå¸¸å¤šçš„æ—¶é—´ï¼Œä»è€Œé€ æˆé˜»å¡ã€‚è¯•ç€æƒ³ä¸€ä¸‹ï¼Œå¦‚æœæµè§ˆå™¨éœ€è¦å¤„ç†ä¼˜å…ˆçº§æ›´é«˜çš„äº‹ä»¶å¦‚ç”¨æˆ·è¾“å…¥ã€ä¿æŒåŠ¨ç”»æµç•…è¿è¡Œï¼Œè¿™æ—¶æµè§ˆå™¨å°±ä¸å¾—ä¸ç­‰åˆ° render æ–¹æ³•æ‰§è¡Œå®Œåå†æ¥å¤„ç†è¿™äº›äº‹æƒ…ã€‚

æ—¢ç„¶é€’å½’ä¼šé€ æˆè¿™ä¹ˆä¸¥é‡çš„é—®é¢˜ï¼Œé‚£æˆ‘ä»¬ä¹‹å‰ä¸ºä»€ä¹ˆè¦é‡‡ç”¨é€’å½’çš„æ–¹å¼å‘¢ï¼Ÿæˆ‘çŒœæ˜¯å› ä¸º React ä¹‹å‰ä¹Ÿæ˜¯é‡‡ç”¨ä¸å¯ä¸­æ–­çš„é€’å½’çš„æ–¹å¼ã€‚ï¼ˆè¯¯

---

```js focus=45:62
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === "object"
          ? child
          : createTextElement(child)
      ),
    },
  }
}
â€‹
function createTextElement(text) {
  return {
    type: "TEXT_ELEMENT",
    props: {
      nodeValue: text,
      children: [],
    },
  }
}

function render(element, container) {
  const dom =
    element.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(element.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(element.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = element.props[name]
    })
â€‹
  element.props.children.forEach(child =>
    render(child, dom)
  )
â€‹
  container.appendChild(dom)
}

let nextUnitOfWork = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(nextUnitOfWork) {
  // TODO
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

èµ°è¿œäº†ï¼Œè®©æˆ‘ä»¬å›åˆ°æ­£é¢˜ï¼Œæ¥å°†è¿™ä¸ªè¿‡ç¨‹å˜å¾—å¯ä¸­æ–­ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬æ¥å°†æ•´ä¸ªä»»åŠ¡æ‹†åˆ†æˆä¸€ä¸ªä¸ªå°çš„ä»»åŠ¡å•å…ƒ work unitï¼Œç„¶ååœ¨æ¯æ¬¡æ‰§è¡Œå®Œä¸€ä¸ªå°çš„ä»»åŠ¡å•å…ƒåè¯¢é—®ä¸€ä¸‹æµè§ˆå™¨æœ‰æ²¡æœ‰å…¶ä»–éœ€è¦ä¼˜å…ˆå¤„ç†çš„äº‹æƒ…ã€‚è¿™ä¸ªåå¤çš„è¿‡ç¨‹æˆ‘ä»¬ç”¨ requestIdleCallback è¿™ä¸ªåŸç”Ÿæ–¹æ³•æ¥å®ç°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåœ¨æµè§ˆå™¨ç©ºé—²çš„æ—¶å€™æ‰§è¡Œï¼Œè¿™æ ·çš„è¯åƒä¸€äº›å…³é”®äº‹ä»¶å¦‚åŠ¨ç”»å’Œç”¨æˆ·è¾“å…¥å°±ä¸ä¼šè¢«å½±å“å»¶è¿Ÿã€‚requestIdleCallback åŒæ—¶ä¹Ÿæä¾›äº†ä¸€ä¸ªç±»ä¼¼äºæˆªæ­¢æ—¶é—´ deadline çš„å‚æ•°ï¼Œå¦‚æœä¼ å…¥çš„æ–¹æ³•æ‰§è¡Œæ—¶é—´è¶…è¿‡äº†è¿™ä¸ªæ—¶é—´ï¼Œå°±ä¼šåœæ­¢æ‰§è¡Œå°†ä¸»åŠ¨æƒäº¤è¿˜åˆ°æµè§ˆå™¨æ‰‹ä¸­ã€‚

æ³¨æ„ React ä¸å†ä½¿ç”¨ requestIdleCallback è¿™ä¸ªæ–¹æ³•ï¼Œå› ä¸ºä»–ä»¬ä¸ºäº†ä¿è¯å…¼å®¹æ€§è‡ªå·±å®ç°äº†ä¸€å¥—ï¼ä¸è¿‡ä»æ–¹æ³•çš„æ¦‚å¿µä¸Šæ˜¯ä¸€è‡´çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±é‡‡ç”¨ requestIdleCallback è¿™ä¸ªæ–¹æ³•ã€‚

---

```js focus=47,55:56,58

```

requestIdlecallback è¿˜ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªæˆªæ­¢æ—¥æœŸå‚æ•°ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ƒæ¥æ£€æŸ¥æˆ‘ä»¬æœ‰å¤šå°‘æ—¶é—´ï¼Œç›´åˆ°æµè§ˆå™¨éœ€è¦å†æ¬¡æ§åˆ¶ä¸ºæ­¢ã€‚

---

```js focus=45,47,50:52,56,60:62

```

åœ¨å¼€å§‹è¿™ä¸ªå¾ªç¯ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆæŒ‡å®šç¬¬ä¸€ä¸ªä»»åŠ¡å•å…ƒï¼Œä¸ºæ­¤æˆ‘ä»¬åˆ›å»ºäº† performUnitOfWork æ–¹æ³•ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•ä¸­éœ€è¦å»æ‰§è¡Œè¿™ä¸ªä»»åŠ¡ï¼ŒåŒæ—¶æœ€åè¿”å›ä¸‹ä¸€ä¸ªéœ€è¦æ‰§è¡Œçš„ä»»åŠ¡å•å…ƒ nextUnitOfWorkã€‚

---

</CH.Scrollycoding>

<CH.Scrollycoding>

```
# withClass[1] my-class
<>
```

## ç¬¬å››æ­¥ï¼šFibers

ä¸ºäº†ç»„ç»‡ä»»åŠ¡å•å…ƒï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ•°æ®ç»“æ„ï¼šfiber treeã€‚

ä¸€ä¸ª fiber å¯¹åº”ä¸€ä¸ªå…ƒç´ ï¼ŒåŒæ—¶æ¯ä¸ª fiber ä¹Ÿæ˜¯æˆ‘ä»¬æ‰€åˆ’åˆ†å‡ºæ¥çš„ä»»åŠ¡å•å…ƒã€‚

é‚£ä¹ˆ fiber tree åˆ°åº•æ˜¯é•¿å•¥æ ·çš„å‘¢ï¼Ÿ

ä¸¾ä¸ª ğŸŒ°ï¼Œæ¯”å¦‚æˆ‘ä»¬æƒ³è¦æ¸²æŸ“å¦‚ä¸‹ä¸€æ£µå…ƒç´ æ ‘ã€‚

```js
Didact.render(
  <div>
    <h1>
      <p />
      <a />
    </h1>
    <h2 />
  </div>,
  container
);
```

å¯¹åº”çš„ fiber tree å°±é•¿ä¸‹é¢è¿™ä¸ªæ ·å­ã€‚

åœ¨ render æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å…ˆåˆ›å»º root fiber å¹¶æŠŠå®ƒä½œä¸ºç¬¬ä¸€ä¸ªä»»åŠ¡å•å…ƒï¼Œå³ç¬¬ä¸€ä¸ª nextUnitOfWorkã€‚å…¶ä½™çš„ä»»åŠ¡ä¼šåœ¨ performUnitOfWork è¿™ä¸ªæ–¹æ³•ä¸­å»å¤„ç†ã€‚å¯¹äºæ¯ä¸ª fiber æˆ‘ä»¬éœ€è¦åœ¨ performUnitOfWork è¿™ä¸ªæ–¹æ³•ä¸­åšä¸‰ä»¶äº‹æƒ…ï¼š

1. å°†å…ƒç´ è½¬æ¢ä¸ºèŠ‚ç‚¹å¹¶æ·»åŠ åˆ° DOM ä¸Šã€‚
2. ä¸ºè¯¥å…ƒç´ çš„å­å…ƒç´  children åˆ›å»º fibersã€‚
3. è®¾ç½®ä¸‹ä¸€ä¸ªä»»åŠ¡å•å…ƒ nextUnitOfWorkã€‚

fiber tree çš„å…¶ä¸­ä¸€ä¸ªç›®æ ‡å°±æ˜¯ä¸ºäº†èƒ½å¤Ÿè®©è®¾ç½®ä¸‹ä¸€ä¸ªä»»åŠ¡å•å…ƒæ›´åŠ å®¹æ˜“ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæ¯ä¸ª fiber éƒ½éœ€è¦æœ‰ä¸€ä¸ªæŒ‡é’ˆï¼ˆé€»è¾‘ä¸Šï¼‰æŒ‡å‘ç¬¬ä¸€ä¸ªå­å…ƒç´  childï¼Œä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å…„å¼ŸèŠ‚ç‚¹ siblingï¼Œä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘çˆ¶èŠ‚ç‚¹ parentã€‚

å½“æˆ‘ä»¬æ‰§è¡Œå®Œä¸€ä¸ª fiber çš„ä»»åŠ¡æ—¶ï¼Œå¦‚æœå®ƒçš„ child æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ ä¸ä¸ºç©ºçš„è¯ï¼Œåˆ™è¯¥å…ƒç´ å°†ä¼šè¢«æŒ‡å®šä¸º nextUnitOfWorkã€‚ä»¥ä¸Šå›¾ä¸­çš„ fiber tree ä¸ºä¾‹ï¼Œå½“æˆ‘ä»¬æ‰§è¡Œå®Œæ ‡ç­¾ä¸º div çš„ fiber çš„ä»»åŠ¡æ—¶ï¼ŒnextUnitOfWork å°†ä¼šæ˜¯å®ƒçš„ child æŒ‡é’ˆæŒ‡å‘çš„æ ‡ç­¾ä¸º h1 çš„ fiberã€‚

å¦‚æœä¸€ä¸ª fiber çš„ child æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ ä¸ºç©ºï¼Œå³è¯¥ fiber ä¸å­˜åœ¨ child æ—¶ï¼Œæˆ‘ä»¬å°†ä¼šæŒ‡å®š sibling å¯¹åº”çš„ fiber ä½œä¸º nextUnitOfWorkã€‚è¿˜æ˜¯ä»¥ä¸Šå›¾çš„ fiber tree ä¸ºä¾‹ï¼Œæ ‡ç­¾ä¸º p çš„ fiber æ²¡æœ‰ childï¼Œæ‰€ä»¥æˆ‘ä»¬å°† p å¯¹åº”çš„ siblingï¼Œå³æ ‡ç­¾ä¸º a çš„ fiber ä½œä¸º nextUnitOfWorkã€‚

å¦‚æœä¸€ä¸ª fiber å³æ²¡æœ‰ child ä¹Ÿæ²¡æœ‰ siblingï¼Œæˆ‘ä»¬å°±æŒ‡å®š nextUnitOfWork ä¸ºè¯¥ fiber çš„å”å” uncleï¼Œå³è¯¥ fiber çš„çˆ¶èŠ‚ç‚¹ parent çš„å…„å¼ŸèŠ‚ç‚¹ siblingã€‚ä¸Šå›¾ fiber tree ä¸­æ ‡ç­¾ä¸º a çš„ fiber å°±æ²¡æœ‰ child å’Œ siblingï¼Œäºæ˜¯å‘ä¸Šå¯»æ‰¾æœ€åæ‰¾åˆ°äº†å®ƒçš„å”å”ï¼Œæ ‡ç­¾ä¸º h2 çš„ fiberã€‚

å¦‚æœè¯¥ fiber æ²¡æœ‰å”å”å‘¢ï¼Ÿæˆ‘ä»¬å°†ä¼šç»§ç»­æ²¿ç€ parent å‘ä¸Šå¯»æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªå­˜åœ¨ sibling çš„ parent æˆ–è€…åˆ°è¾¾æ ¹ rootã€‚å¦‚æœæ˜¯åè€…çš„è¯ï¼Œé‚£å°±è¯´æ˜æˆ‘ä»¬å·²ç»æ‰§è¡Œå®Œäº†æœ¬æ¬¡æ¸²æŸ“ render çš„æ‰€æœ‰ä»»åŠ¡ã€‚

---

æ¥ç€ï¼Œå°±è®©æˆ‘ä»¬æŠŠæƒ³æ³•è½¬æ¢ä¸ºä»£ç å§ã€‚

åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå°† render æ–¹æ³•ä¸­ä¹‹å‰çš„ä»£ç ç§»é™¤

```js focus=1:21
function render(element, container) {
  const dom =
    element.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(element.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(element.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = element.props[name]
    })
â€‹
  element.props.children.forEach(child =>
    render(child, dom)
  )
â€‹
  container.appendChild(dom)
}

let nextUnitOfWork = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(nextUnitOfWork) {
  // TODO
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å¹¶å°†ç§»é™¤çš„é‚£éƒ¨åˆ†æ”¾åˆ°æ–¹æ³• createDom ä¸­å»ï¼Œè¿™å°†ä¼šåœ¨ä¹‹åç”¨åˆ°

```js focus=1,15:21
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function render(element, container) {
  // TODO set next unit of work
}
â€‹
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  // TODO add dom node
  // TODO create new fibers
  // TODO return next unit of work
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä¸“æ³¨äºå®ç° render æ–¹æ³•ã€‚

é¦–å…ˆï¼Œåœ¨ render æ–¹æ³•ä¸­å°† nextUnitOfWork åˆå§‹åŒ–ä¸º fiber tree çš„æ ¹ã€‚

```js focus=17:25
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function render(element, container) {
  nextUnitOfWork = {
    dom: container,
    props: {
      children: [element],
    },
  }
}
â€‹
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  // TODO add dom node
  // TODO create new fibers
  // TODO return next unit of work
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

æ¥ç€å½“æµè§ˆå™¨æœ‰ç©ºçš„æ—¶å€™å°±ä¼šè°ƒç”¨æˆ‘ä»¬çš„ä»»åŠ¡å¾ªç¯ workLoopï¼Œæˆ‘ä»¬å°±ä¼šä»æ ¹ root å¼€å§‹æ‰§è¡Œä»»åŠ¡ã€‚

```js focus=28,31:33,41:45

```

---

åœ¨ performUnitOfWork ä¸­ï¼Œæˆ‘ä»¬è¦å…ˆä¸ºä¼ å…¥çš„ fiber åˆ›å»ºå¯¹åº”çš„ DOM èŠ‚ç‚¹ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹å¹¶å°†å…¶é™„åŠ åˆ° DOM,å¹¶ä¸”æˆ‘ä»¬ä¼šä½¿ç”¨ fiber.dom å±æ€§æ¥å®šä½è¯¥ DOM èŠ‚ç‚¹ã€‚

```js focus=42:48
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function render(element, container) {
  nextUnitOfWork = {
    dom: container,
    props: {
      children: [element],
    },
  }
}
â€‹
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  if (fiber.parent) {
    fiber.parent.dom.appendChild(fiber.dom)
  }
â€‹
  // TODO create new fibers
  // TODO return next unit of work
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ç„¶åå¯¹è¯¥ fiber çš„å­å…ƒç´  children åˆ›å»ºç›¸åº”çš„ fiberã€‚

```js focus=50:63
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function render(element, container) {
  nextUnitOfWork = {
    dom: container,
    props: {
      children: [element],
    },
  }
}
â€‹
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  if (fiber.parent) {
    fiber.parent.dom.appendChild(fiber.dom)
  }
â€‹
  const elements = fiber.props.children
  let index = 0
  let prevSibling = null
â€‹
  while (index < elements.length) {
    const element = elements[index]
â€‹
    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }
  }

  // TODO return next unit of work
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å†æ ¹æ®æ˜¯å¦æ˜¯ç¬¬ä¸€ä¸ªå­å…ƒç´ æ¥è®¾ç½® child å’Œ siblingã€‚

```js focus=64:72
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function render(element, container) {
  nextUnitOfWork = {
    dom: container,
    props: {
      children: [element],
    },
  }
}
â€‹
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  if (fiber.parent) {
    fiber.parent.dom.appendChild(fiber.dom)
  }

  const elements = fiber.props.children
  let index = 0
  let prevSibling = null
â€‹
  while (index < elements.length) {
    const element = elements[index]
â€‹
    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }

   if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }
â€‹
    prevSibling = newFiber
    index++
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

æœ€åï¼Œæˆ‘ä»¬æ ¹æ®ä¹‹å‰æåˆ°çš„ child-sibling-uncleï¼ˆparentâ€™s siblingï¼‰çš„é¡ºåºæ¥æŒ‡å®šä¸€ä¸‹ nextUnitOfWorkã€‚

```js focus=74:83
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function render(element, container) {
  nextUnitOfWork = {
    dom: container,
    props: {
      children: [element],
    },
  }
}
â€‹
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  if (fiber.parent) {
    fiber.parent.dom.appendChild(fiber.dom)
  }

  const elements = fiber.props.children
  let index = 0
  let prevSibling = null
â€‹
  while (index < elements.length) {
    const element = elements[index]

    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å®Œæ•´çš„ performUnitOfWork æ–¹æ³•å¦‚ä¸‹ï¼š

```js focus=40:84

```

---

## ç¬¬äº”æ­¥ï¼šRender and Commit Phases

è¿™é‡Œæˆ‘ä»¬åˆé‡åˆ°äº†ä¸€ä¸ªé—®é¢˜ã€‚

```js focus=41,45:48

```

æ¯æ¬¡æˆ‘ä»¬åœ¨å¤„ç†ä¸€ä¸ªå…ƒç´ æ—¶éƒ½éœ€è¦å°†å…¶æ–°å»ºçš„èŠ‚ç‚¹æ·»åŠ åˆ° DOM ä¸Šå»ã€‚ä½†æ˜¯ä¸è¦å¿˜äº†ï¼Œæµè§ˆå™¨èƒ½å¤Ÿåœ¨æˆ‘ä»¬æ¸²æŸ“å®Œæ•´æ£µ fiber tree ä¹‹å‰ä¸­æ–­æˆ‘ä»¬çš„æ¸²æŸ“è¿‡ç¨‹çš„ã€‚å‡ºç°è¿™ç§æƒ…å†µæ—¶ï¼Œç”¨æˆ·å°†ä¼šçœ‹åˆ°ä¸€ä¸ªä¸å®Œæ•´çš„ UI ç•Œé¢ï¼Œé‚£æ˜¯æˆ‘ä»¬ä¸æƒ³çœ‹åˆ°çš„ã€‚

---

æ‰€ä»¥ï¼Œæˆ‘ä»¬è¦å°†ä¿®æ”¹ DOM çš„è¿™éƒ¨åˆ†ä»£ç ä» performUnitOfWork æ–¹æ³•ä¸­ç§»é™¤ã€‚

```js focus=41
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function render(element, container) {
  nextUnitOfWork = {
    dom: container,
    props: {
      children: [element],
    },
  }
}
â€‹
let nextUnitOfWork = null

function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  let index = 0
  let prevSibling = null
â€‹
  while (index < elements.length) {
    const element = elements[index]

    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ç›¸å¯¹åœ°ï¼Œæˆ‘ä»¬éœ€è¦ä¿æŒå¯¹ fiber tree çš„æ ¹ root çš„å¼•ç”¨ã€‚æˆ‘ä»¬å°†å…¶å¼•ç”¨å‘½åä¸º wipRootï¼ˆwork in progress rootï¼‰ã€‚

```js focus=18,24,28
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  let index = 0
  let prevSibling = null
â€‹
  while (index < elements.length) {
    const element = elements[index]

    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ä¸€æ—¦æˆ‘ä»¬å¤„ç†å®Œäº†æ‰€æœ‰ä»»åŠ¡å•å…ƒï¼ˆå¯ä»¥æ ¹æ® nextUnitOfWork æ˜¯å¦ä¸ºç©ºæ¥åˆ¤æ–­ï¼‰ï¼Œæˆ‘ä»¬å†å°†æ•´æ£µ fiber tree æäº¤åˆ° DOM ä¸Šã€‚

```js focus=17:19,34,43:45,48
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  // TODO add nodes to dom
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  let index = 0
  let prevSibling = null
â€‹
  while (index < elements.length) {
    const element = elements[index]

    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

åœ¨ commitRoot è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä»¥é€’å½’çš„æ–¹å¼å°†æ‰€æœ‰èŠ‚ç‚¹æ·»åŠ åˆ° DOM ä¸Šã€‚

```js focus=17:30
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  commitWork(wipRoot.child)
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  let index = 0
  let prevSibling = null
â€‹
  while (index < elements.length) {
    const element = elements[index]

    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

## ç¬¬å…­æ­¥ï¼šReconciliation

ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯å®ç°äº†æ·»åŠ èŠ‚ç‚¹åˆ° DOM ä¸Šï¼Œåˆ é™¤å’Œæ›´æ–°å‘¢ï¼Ÿ

è¿™å°±æ˜¯æœ¬èŠ‚è¦å®ç°çš„ç›®æ ‡ï¼Œä¸ºæ­¤æˆ‘ä»¬éœ€è¦å°†æœ¬æ¬¡æ¸²æŸ“çš„ fiber tree å³ wipRoot ä¸ä¸Šä¸€æ¬¡æäº¤åˆ° DOM ä¸Šçš„ fiber tree è¿›è¡Œæ¯”è¾ƒã€‚

---

é‚£ä¹ˆï¼Œåœ¨æ¯æ¬¡æäº¤é˜¶æ®µå®Œæˆæ—¶ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¿æŒå¯¹æœ¬æ¬¡æäº¤åˆ° DOM ä¸Šçš„ fiber tree çš„å¼•ç”¨ï¼Œä»¥æ–¹ä¾¿ä¸‹æ¬¡æ¯”è¾ƒï¼Œæˆ‘ä»¬å°†å…¶å¼•ç”¨å‘½åä¸º currentRootã€‚åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿä¸ºæ¯ä¸ª fiber æ·»åŠ  alternate å±æ€§ï¼ŒæŒ‡å‘æ—§çš„ fiberï¼Œå³åœ¨ä¸Šä¸ªæäº¤é˜¶æ®µæˆ‘ä»¬æ·»åŠ åˆ° DOM ä¸Šçš„ fiberã€‚

```js focus=17,19,21,33:34,39:40,42,45
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  let index = 0
  let prevSibling = null
â€‹
  while (index < elements.length) {
    const element = elements[index]

    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

æ¥ç€ï¼Œè®©æˆ‘ä»¬ä» performUnitOfWork æ–¹æ³•ä¸­æŠ½ç¦»åˆ›å»ºæ–°çš„ fiber é‚£éƒ¨åˆ†ä»£ç ï¼ŒåŸä»£ç å¦‚ä¸‹ï¼š

```js focus=66:105

```

---

å°†æŠ½ç¦»å‡ºæ¥çš„æ–¹æ³•æ”¾åˆ° reconcileChildren æ–¹æ³•ä¸­ï¼Œæ”¹é€ åçš„ä»£ç å¦‚ä¸‹ï¼š

```js focus=66,71:72,86
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {

  let index = 0
  let prevSibling = null
â€‹
  while (index < elements.length) {
    const element = elements[index]

    const newFiber = {
      type: element.type,
      props: element.props,
      parent: fiber,
      dom: null,
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

åœ¨ reconcileChildren è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å°†å¯¹æ—§çš„ fiber ä¸æ–°çš„å…ƒç´ è¿›è¡Œè°ƒå’Œ reconclieã€‚

```js focus=86

```

---

æˆ‘ä»¬åŒæ—¶è¿­ä»£æ—§ fiber çš„å­å…ƒç´  wipFiber.alternate ä»¥åŠ elements æ•°ç»„ä¸­æˆ‘ä»¬æƒ³è¦è°ƒå’Œçš„å…ƒç´ ã€‚

å¦‚æœæˆ‘ä»¬å¿½ç•¥åŒæ—¶è¿­ä»£é“¾è¡¨å’Œæ•°ç»„æ‰€éœ€è¦æ³¨æ„çš„é‚£äº›é€šç”¨ä»£ç ï¼Œåªå…³å¿ƒå…¶ä¸­æœ€é‡è¦çš„éƒ¨åˆ†ï¼šoldFiber å’Œ elementï¼Œelement æ˜¯æœ¬æ¬¡è°ƒå’Œæˆ‘ä»¬æƒ³è¦æ¸²æŸ“åˆ° DOM ä¸Šçš„ fiberï¼ŒoldFiber æ˜¯æˆ‘ä»¬ä¸Šæ¬¡æ¸²æŸ“åˆ° DOM ä¸Šçš„ fiberã€‚æˆ‘ä»¬éœ€è¦æ¯”è¾ƒå®ƒä»¬çš„å·®å¼‚ã€‚

```js focus=86:89,91:99
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    // TODO compare oldFiber to element
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

æˆ‘ä»¬é‡‡ç”¨ä»¥ä¸‹æ–¹å¼æ¥å¯¹å®ƒä»¬è¿›è¡Œæ¯”è¾ƒï¼š

1. å¦‚æœ oldFiber å’Œ element çš„ type ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥ä¿ç•™å…¶ DOM èŠ‚ç‚¹ï¼Œåªæ›´æ–°å…¶ä¸­çš„å±æ€§ propsã€‚
2. å¦‚æœå®ƒä»¬çš„ type ä¸ä¸€æ ·ï¼š

- å¯¹äº elementï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºæ–°çš„ DOM èŠ‚ç‚¹ã€‚
- å¯¹äº oldFiberï¼Œæˆ‘ä»¬éœ€è¦ç§»é™¤æ—§çš„ DOM èŠ‚ç‚¹ã€‚

3. åœ¨çœŸæ­£çš„ React ä¸­ï¼Œè¿™é‡Œä¼šä½¿ç”¨ key æ¥ä¼˜åŒ–è°ƒå’Œã€‚æ¯”å¦‚ï¼Œå®ƒèƒ½å¤Ÿæ¢æµ‹åˆ°æ•°ç»„ä¸­å…ƒç´ çš„ä½ç½®æ˜¯å¦å‘ç”Ÿå˜åŒ–ã€‚

```js focus=99:112
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      // TODO update the node
    }
    if (element && !sameType) {
      // TODO add this node
    }
    if (oldFiber && !sameType) {
      // TODO delete the oldFiber's node
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å¦‚æœ oldFiber å’Œ element çš„ type ä¸€è‡´æ—¶ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ–°çš„ fiberï¼Œå…¶ä¸­ä¿æŒåŸæ¥çš„ DOM ä¸å˜ï¼Œå±æ€§ props é‡‡ç”¨ element.propsã€‚
åŒæ—¶æˆ‘ä»¬ä¸ºæ–°çš„ fiber æ–°å¢äº† effectTag å±æ€§ã€‚è¿™ä¸ªå±æ€§æˆ‘ä»¬å°†ä¼šåœ¨åé¢çš„æäº¤é˜¶æ®µç”¨åˆ°ã€‚

```js focus=114:123
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      // TODO add this node
    }
    if (oldFiber && !sameType) {
      // TODO delete the oldFiber's node
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å¯¹äº type ä¸ä¸€è‡´çš„æƒ…å†µï¼Œæˆ‘ä»¬ä¸º element åˆ›å»ºæ–°çš„ fiberï¼Œå¹¶å°† effectTag è®¾ç½®ä¸º PLACEMENTã€‚

```js focus=114:123
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      // TODO delete the oldFiber's node
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å¯¹äº oldFiberï¼Œæˆ‘ä»¬éœ€è¦åˆ é™¤å¯¹åº”çš„ nodeã€‚å› ä¸ºä¸ä¼šåˆ›å»ºæ–°çš„ fiberï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨æ—§çš„ fiber ä¸Šè®¾ç½® effectTag ä¸º DELETIONã€‚

```js focus=125:128
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ä½†æ˜¯åœ¨æäº¤é˜¶æ®µçš„æ—¶å€™ï¼Œæˆ‘ä»¬æ“ä½œçš„ fiber tree æ˜¯ wipRootï¼Œå¹¶ä¸éœ€è¦æ—§çš„ fiberã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦è®°ä½æˆ‘ä»¬éœ€è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼ˆé€šè¿‡ deletions æ•°ç»„æ¥å­˜æ”¾ï¼‰ã€‚

```js focus=31,41,48
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

æ¥ç€ï¼Œæˆ‘ä»¬åœ¨æäº¤é˜¶æ®µæ›´æ–° DOM æ—¶ï¼Œåªéœ€è¦æ“ä½œ deletions æ•°ç»„ä¸­çš„ fiber å°±å¯ä»¥äº†ã€‚

```js focus=17,19,22
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  domParent.appendChild(fiber.dom)
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ç°åœ¨ï¼Œå°±è®©æˆ‘ä»¬åœ¨ commitWork æ–¹æ³•ä¸­æ ¹æ® effectTag æ¥å¯¹ DOM è¿›è¡Œä¸åŒçš„æ“ä½œã€‚

```js focus=24:32

```

---

å¦‚æœ effectTag æ˜¯ PLACEMENTï¼Œå°±åƒä¹‹å‰ä¸€æ ·ï¼Œå°†èŠ‚ç‚¹ç›´æ¥æ·»åŠ åˆ° DOM ä¸Šå³å¯ã€‚

```js focus=29:34
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
  if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å¦‚æœ effectTag æ˜¯ DELETIONï¼Œä¸ PLACEMENT ç›¸åï¼Œæˆ‘ä»¬å°†èŠ‚ç‚¹ä» DOM ä¸Šç§»é™¤ã€‚

```js focus=34:36
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å¦‚æœ effectTag æ˜¯ UPDATEï¼Œæˆ‘ä»¬éœ€è¦åœ¨å·²å­˜åœ¨çš„ DOM ä¸Šæ›´æ–°æ”¹å˜äº†çš„å±æ€§ propsã€‚å› ä¸ºæ›´æ–°æ¯”è¾ƒå¤æ‚ï¼Œæˆ‘ä»¬å°†å…·ä½“çš„å®ç°æ”¾åœ¨ updateDom è¿™ä¸ªæ–¹æ³•ä¸­ã€‚

```js focus=34:42
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}
â€‹
function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
   if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)

```

---

æ–°å»ºä¸€ä¸ª updateDom æ–¹æ³•

```js focus=17:19
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

â€‹function updateDom(dom, prevProps, nextProps) {
  // TODO
 }

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
   if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

åœ¨æ–¹æ³• updateDom ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ¯”è¾ƒæ–°æ—§ fiber çš„å±æ€§ propsï¼Œåˆ é™¤æ—§çš„ï¼Œæ·»åŠ æ–°çš„ä»¥åŠå˜æ›´å€¼å‘ç”Ÿæ”¹å˜çš„ã€‚

```js focus=17:37
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
   if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ç­‰ç­‰ï¼Œè¿˜æœ‰ä¸€ç§ç‰¹æ®Šçš„å±æ€§æˆ‘ä»¬æ²¡æœ‰å¤„ç†ï¼Œé‚£å°±æ˜¯ç›‘å¬äº‹ä»¶ï¼Œåœ¨ React ä¸­åˆæˆäº‹ä»¶æœ‰ä¸€ä¸ªç‰¹ç‚¹ï¼Œå°±æ˜¯ä»¥ on å¼€å¤´ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬åœ¨ props ä¸­è¯†åˆ«åˆ°ç›‘å¬äº‹ä»¶æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å¯¹å…¶ç‰¹æ®Šå¤„ç†ã€‚

```js focus=17,18
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
   if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å¦‚æœç›‘å¬äº‹ä»¶å‘ç”Ÿäº†æ”¹å˜ï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒä»èŠ‚ç‚¹ä¸Šç§»é™¤ã€‚

```js focus=24:39
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
   if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ç„¶åæˆ‘ä»¬æ–°çš„ç›‘å¬äº‹ä»¶æ·»åŠ åˆ°å¯¹åº”çš„èŠ‚ç‚¹ä¸Šå»ã€‚

```js focus=57:69
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
   if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
const element = (
  <div id="foo">
    <a>bar</a>
    <b />
  </div>
)
const container = document.getElementById("root")
Didact.render(element, container)
```

è¿™æ ·ï¼Œæˆ‘ä»¬å°±å®ç°äº†æ›´æ–°å’Œåˆ é™¤ï¼Œè®©æˆ‘ä»¬åœ¨ [codesandbox](https://codesandbox.io/s/didact-6-96533) ä¸Šçœ‹çœ‹åŠ å…¥äº†è°ƒå’Œçš„ Didact æ•ˆæœæ€ä¹ˆæ ·ã€‚

---

</CH.Scrollycoding>

<CH.Scrollycoding>

## ç¬¬ä¸ƒæ­¥ï¼šFunction Components

æ¥ä¸‹æ¥æˆ‘ä»¬è¦åšçš„å°±æ˜¯è®© Didact æ”¯æŒå‡½æ•°ç»„ä»¶ã€‚

é¦–å…ˆï¼Œè®©æˆ‘ä»¬æ¢ä¸ª ğŸŒ°ï¼Œä½¿ç”¨ä¸€ä¸ªç®€å•çš„å‡½æ•°ç»„ä»¶ï¼Œå…¶è¿”å›ä¸€ä¸ª h1 å…ƒç´ ã€‚

```js focus=235:241
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
   if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
â€‹
  const elements = fiber.props.children
  reconcileChildren(fiber, elements)
â€‹
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
function App(props) {
  return <h1>Hi {props.name}</h1>
}
const element = <App name="foo" />
const container = document.getElementById("root")
Didact.render(element, container)
```

å¦‚æœæˆ‘ä»¬å°†ä»¥ä¸Šçš„ JSX è½¬æ¢ä¸º JSï¼Œå°†ä¼šæ˜¯ä¸‹é¢è¿™ä¸ªæ ·å­ï¼š
`function App(props) {
  return Didact.createElement("h1", null, "Hi ", props.name);
}
const element = Didact.createElement(App, {
  name: "foo",
});`

---

å‡½æ•°ç»„ä»¶åœ¨ä¸¤ä¸ªæ–¹é¢æœ‰æ‰€ä¸åŒï¼š

- å‡½æ•°ç»„ä»¶çš„ fiber æ²¡æœ‰ä¸ä¹‹å¯¹åº”çš„ DOM èŠ‚ç‚¹ã€‚
- å­å…ƒç´  children æ¥è‡ªè¿è¡Œçš„å‡½æ•°è€Œä¸æ˜¯ç›´æ¥ä» props é‡Œé¢è·å–ã€‚

```js focus=140:146

```

---

è¿™æ ·çš„è¯ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ–¹æ³• performUnitOfWork åšå‡ºä¿®æ”¹ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬æ£€æŸ¥ fiber çš„ type æ˜¯å¦ä¸º functionï¼Œå¹¶ä»¥æ­¤ä¸ºä¾æ®æ¥åˆ¤æ–­æ˜¯å¦é‡‡ç”¨ä¸åŒçš„æ›´æ–°æ–¹æ³•ã€‚

```js focus=141:147,160:169
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
   if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
function updateFunctionComponent(fiber) {
  // TODO
}
â€‹
function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
function App(props) {
  return <h1>Hi {props.name}</h1>
}
const element = <App name="foo" />
const container = document.getElementById("root")
Didact.render(element, container)

```

---

åœ¨ updateHostComponent æ–¹æ³•ä¸­ä½¿ç”¨åŸæ¥çš„æ›´æ–°æ–¹å¼ï¼Œè€Œåœ¨ updateFunctionComponent æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å…ˆæ‰§è¡Œè¿™ä¸ªå‡½æ•°å»è·å–å®ƒçš„å­å…ƒç´ ã€‚

```js focus=160:163
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  const domParent = fiber.parent.dom
   if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
function updateFunctionComponent(fiber) {
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}
â€‹
function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
function App(props) {
  return <h1>Hi {props.name}</h1>
}
const element = <App name="foo" />
const container = document.getElementById("root")
Didact.render(element, container)

```

åœ¨æˆ‘ä»¬çš„ ğŸŒ° ä¸­ï¼Œfiber.type æŒ‡çš„å°±æ˜¯ App è¿™ä¸ªå‡½æ•°ï¼Œå½“æˆ‘ä»¬è¿è¡Œå®ƒæ—¶ï¼Œå°±èƒ½ä»è¿”å›å€¼ä¸­è·å–å­å…ƒç´  h1ã€‚ä¸€æ—¦æˆ‘ä»¬è·å–åˆ°äº†å­å…ƒç´ ï¼Œå°±å¯ä»¥åƒä¹‹å‰ä¸€æ ·æ¥è¿›è¡Œè°ƒå’Œï¼Œä¸éœ€è¦åœ¨è¿™ä¸ªæ–¹æ³•ä¸­é¢å¤–åšå…¶ä»–äº‹æƒ…ã€‚

---

æ—¢ç„¶ç°åœ¨æˆ‘ä»¬ä¼šé‡åˆ°æ²¡æœ‰ DOM èŠ‚ç‚¹çš„ fiberï¼Œæˆ‘ä»¬éœ€è¦åœ¨ commitWork è¿™ä¸ªæ–¹æ³•ä¸­åšå‡ºä¸¤ç‚¹æ”¹å˜ã€‚

```js focus=79:103

```

---

ç¬¬ä¸€ï¼Œæ²¿ç€ parent æŒ‡é’ˆæ‰¾åˆ°ä¸€ä¸ª DOM èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œç›´åˆ°æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªå¸¦æœ‰ DOM èŠ‚ç‚¹çš„ fiberã€‚

```js focus=83:87,93
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom
â€‹
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    domParent.removeChild(fiber.dom)
  }
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
function updateFunctionComponent(fiber) {
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}
â€‹
function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
function App(props) {
  return <h1>Hi {props.name}</h1>
}
const element = <App name="foo" />
const container = document.getElementById("root")
Didact.render(element, container)

```

---

ç¬¬äºŒï¼Œå½“åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬åŒæ ·éœ€è¦æ²¿ç€ child æŒ‡é’ˆï¼Œæ‰¾åˆ°ä¸€ä¸ªå¸¦æœ‰ DOM èŠ‚ç‚¹çš„ fiberã€‚

```js focus=103:117
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom
â€‹
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    commitDeletion(fiber, domParent)
  }
â€‹
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function commitDeletion(fiber, domParent) {
  if (fiber.dom) {
    domParent.removeChild(fiber.dom)
  } else {
    commitDeletion(fiber.child, domParent)
  }
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
function updateFunctionComponent(fiber) {
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}
â€‹
function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
}
â€‹
/** @jsx Didact.createElement */
function App(props) {
  return <h1>Hi {props.name}</h1>
}
const element = <App name="foo" />
const container = document.getElementById("root")
Didact.render(element, container)


```

---

## ç¬¬å…«æ­¥ï¼šHooks

æœ€åä¸€æ­¥ï¼Œæ—¢ç„¶æˆ‘ä»¬å·²ç»æœ‰äº†å‡½æ•°ç»„ä»¶ï¼Œè®©æˆ‘ä»¬ä¹ŸæŠŠ state åŠ è¿›æ¥å§ã€‚

```js focus=261:267

```

---

è®©æˆ‘ä»¬ä»¥ç»å…¸çš„è®¡æ•°å™¨ç»„ä»¶ä¸ºä¾‹ï¼Œæ¯ç‚¹å‡»å®ƒä¸€æ¬¡ï¼Œå®ƒçš„å€¼å°±å¢åŠ  1ã€‚

æ³¨æ„è¿™é‡Œæˆ‘ä»¬å·²ç»æ›¿æ¢æˆäº† Didact.useState æ¥è·å–å¹¶æ›´æ–°è®¡æ•°å™¨çš„å€¼ã€‚

åœ¨æ–¹æ³• updateFunctionComponent ä¸­æˆ‘ä»¬ä¼šè°ƒç”¨ Counter è¿™ä¸ªå‡½æ•°ç»„ä»¶ï¼Œå¹¶ä¸”åœ¨è¿™ä¸ªæ–¹æ³•ä¸­æˆ‘ä»¬è¿˜ä¼šè°ƒç”¨ useState æ–¹æ³•ã€‚

```js focus=260:277
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom
â€‹
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    commitDeletion(fiber, domParent)
  }
â€‹
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function commitDeletion(fiber, domParent) {
  if (fiber.dom) {
    domParent.removeChild(fiber.dom)
  } else {
    commitDeletion(fiber.child, domParent)
  }
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
function updateFunctionComponent(fiber) {
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}

function useState(initial) {
  // TODO
}
â€‹
function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
  useState,
}
â€‹
/** @jsx Didact.createElement */
function Counter() {
  const [state, setState] = Didact.useState(1)
  return (
    <h1 onClick={() => setState(c => c + 1)}>
      Count: {state}
    </h1>
  )
}
const element = <Counter />
const container = document.getElementById("root")
Didact.render(element, container)
```

---

è¿™æ˜¯æˆ‘ä»¬ä»ç¤ºä¾‹ä¸­è°ƒç”¨è®¡æ•°å™¨å‡½æ•°çš„åœ°æ–¹ã€‚åœ¨è¯¥åŠŸèƒ½ä¸­ï¼Œæˆ‘ä»¬ç§°ä¸º useStateã€‚

```js focus=179:181
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom
â€‹
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    commitDeletion(fiber, domParent)
  }
â€‹
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function commitDeletion(fiber, domParent) {
  if (fiber.dom) {
    domParent.removeChild(fiber.dom)
  } else {
    commitDeletion(fiber.child, domParent)
  }
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
function updateFunctionComponent(fiber) {
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}

function useState(initial) {
  // TODO
}
â€‹
function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
  useState,
}
â€‹
/** @jsx Didact.createElement */
function Counter() {
  const [state, setState] = Didact.useState(1)
  return (
    <h1 onClick={() => setState(c => c + 1)}>
      Count: {state}
    </h1>
  )
}
const element = <Counter />
const container = document.getElementById("root")
Didact.render(element, container)
```

---

æˆ‘ä»¬éœ€è¦åœ¨è°ƒç”¨å‡½æ•°ç»„ä»¶ä¹‹å‰åˆå§‹åŒ–ä¸€äº›å…¨å±€å˜é‡ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥åœ¨ Usestate å‡½æ•°å†…ä½¿ç”¨å®ƒä»¬ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬è®¾ç½® wipFiberï¼ˆwork in process fiberï¼‰ã€‚

åŒæ—¶ï¼Œä¸ºäº†å®ç°åœ¨åŒä¸€ä¸ªç»„ä»¶ä¸­èƒ½å¤Ÿè°ƒç”¨ useState æ–¹æ³•å¤šæ¬¡ï¼Œæˆ‘ä»¬ä¸º fiber æ·»åŠ ä¸€ä¸ª hooks æ•°ç»„ã€‚å¹¶ä¸”æˆ‘ä»¬è®°å½•å½“å‰çš„ hook ç´¢å¼•ã€‚

```js focus=174:183
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom
â€‹
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    commitDeletion(fiber, domParent)
  }
â€‹
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function commitDeletion(fiber, domParent) {
  if (fiber.dom) {
    domParent.removeChild(fiber.dom)
  } else {
    commitDeletion(fiber.child, domParent)
  }
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
let wipFiber = null
let hookIndex = null
â€‹
function updateFunctionComponent(fiber) {
  wipFiber = fiber
  hookIndex = 0
  wipFiber.hooks = []
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}

function useState(initial) {
  // TODO
}
â€‹
function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
  useState,
}
â€‹
/** @jsx Didact.createElement */
function Counter() {
  const [state, setState] = Didact.useState(1)
  return (
    <h1 onClick={() => setState(c => c + 1)}>
      Count: {state}
    </h1>
  )
}
const element = <Counter />
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å½“å‡½æ•°ç»„ä»¶è°ƒç”¨ useState æ–¹æ³•æ—¶ï¼Œæˆ‘ä»¬å…ˆæ£€æŸ¥å…¶ä¸­æ˜¯å¦å­˜åœ¨æ—§çš„ hookã€‚å…·ä½“æ£€æŸ¥çš„æ–¹å¼æ˜¯é€šè¿‡ fiber çš„ alternate å±æ€§æ¥æ‰¾åˆ°æ—§çš„ fiberï¼Œå†é€šè¿‡ hookIndex æ‰¾åˆ°æ—§ fiber ä¸Šå¯¹åº”çš„ hookã€‚

å¦‚æœå­˜åœ¨æ—§çš„ hookï¼Œæˆ‘ä»¬ç›´æ¥ä»å…¶ä¸­å¤åˆ¶ state åˆ°æ–°çš„ hook ä¸­ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œæˆ‘ä»¬å…ˆåˆå§‹åŒ– stateã€‚

ç„¶åæˆ‘ä»¬å°†æ–°çš„ hook æ·»åŠ åˆ° fiber çš„ hooks æ•°ç»„ä¸­å»ï¼Œå¹¶è®©ç´¢å¼• hookIndex å¢åŠ  1ã€‚

æœ€åè¿”å› stateã€‚

```js focus=185:197
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom
â€‹
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    commitDeletion(fiber, domParent)
  }
â€‹
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function commitDeletion(fiber, domParent) {
  if (fiber.dom) {
    domParent.removeChild(fiber.dom)
  } else {
    commitDeletion(fiber.child, domParent)
  }
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
let wipFiber = null
let hookIndex = null
â€‹
function updateFunctionComponent(fiber) {
  wipFiber = fiber
  hookIndex = 0
  wipFiber.hooks = []
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}

function useState(initial) {
  const oldHook =
    wipFiber.alternate &&
    wipFiber.alternate.hooks &&
    wipFiber.alternate.hooks[hookIndex]
  const hook = {
    state: oldHook ? oldHook.state : initial,
  }
â€‹
  wipFiber.hooks.push(hook)
  hookIndex++
  return [hook.state]
}

function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
  useState,
}
â€‹
/** @jsx Didact.createElement */
function Counter() {
  const [state, setState] = Didact.useState(1)
  return (
    <h1 onClick={() => setState(c => c + 1)}>
      Count: {state}
    </h1>
  )
}
const element = <Counter />
const container = document.getElementById("root")
Didact.render(element, container)
```

---

useState æ–¹æ³•ä¹Ÿåº”è¯¥è¿”å›ä¸€ä¸ªç”¨æ¥æ›´æ–° state çš„æ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬å®šä¹‰äº† setState æ–¹æ³•æ¥æ¥å—ä¸€ä¸ªåŠ¨ä½œ actionï¼ˆæ¯”å¦‚åœ¨è®¡æ•°å™¨ç»„ä»¶ä¸­è¿™ä¸ªåŠ¨ä½œå°±æ˜¯å¢åŠ  1 çš„æ–¹æ³•ï¼‰ã€‚æˆ‘ä»¬ä¸º hook æ–°å¢ä¸€ä¸ªé˜Ÿåˆ— queueï¼Œå¹¶å°† action æ”¾å…¥å…¶ä¸­ã€‚

ç„¶åæˆ‘ä»¬éœ€è¦åšçš„äº‹æƒ…å°±è·Ÿä¹‹å‰æˆ‘ä»¬åœ¨ render æ–¹æ³•ä¸­æ‰€åšçš„ç±»ä¼¼ï¼ŒæŒ‡å®š nextUnitOfWork ä¸ºæ–°çš„ wipRootï¼Œè¿™æ · workLoop æ–¹æ³•å°±èƒ½å¤Ÿå¼€å¯ä¸€æ¬¡æ–°çš„æ¸²æŸ“é˜¶æ®µã€‚

```js focus=190,192,195:204,208
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom
â€‹
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    commitDeletion(fiber, domParent)
  }
â€‹
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function commitDeletion(fiber, domParent) {
  if (fiber.dom) {
    domParent.removeChild(fiber.dom)
  } else {
    commitDeletion(fiber.child, domParent)
  }
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
let wipFiber = null
let hookIndex = null
â€‹
function updateFunctionComponent(fiber) {
  wipFiber = fiber
  hookIndex = 0
  wipFiber.hooks = []
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}

function useState(initial) {
  const oldHook =
    wipFiber.alternate &&
    wipFiber.alternate.hooks &&
    wipFiber.alternate.hooks[hookIndex]
   const hook = {
    state: oldHook ? oldHook.state : initial,
    queue: [],
  }
â€‹
  const setState = action => {
    hook.queue.push(action)
    wipRoot = {
      dom: currentRoot.dom,
      props: currentRoot.props,
      alternate: currentRoot,
    }
    nextUnitOfWork = wipRoot
    deletions = []
  }
â€‹
  wipFiber.hooks.push(hook)
  hookIndex++
  return [hook.state, setState]

}

function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
  useState,
}
â€‹
/** @jsx Didact.createElement */
function Counter() {
  const [state, setState] = Didact.useState(1)
  return (
    <h1 onClick={() => setState(c => c + 1)}>
      Count: {state}
    </h1>
  )
}
const element = <Counter />
const container = document.getElementById("root")
Didact.render(element, container)
```

---

ä½†æˆ‘ä»¬è¿˜æ²¡æœ‰æ‰§è¡Œè¿™ä¸ªåŠ¨ä½œã€‚

æˆ‘ä»¬å°†ä¼šåœ¨ä¸‹æ¬¡æ¸²æŸ“è¿™ä¸ªç»„ä»¶çš„æ—¶å€™å†æ‰§è¡Œè¿™ä¸ªåŠ¨ä½œï¼Œæˆ‘ä»¬ä¼šä»æ—§çš„ hook ä¸Šçš„ queue ä¸­è·å–æ‰€æœ‰çš„ actionï¼Œå¹¶ä¸”ä¸€ä¸ªä¸€ä¸ªåœ°æ‰§è¡Œï¼Œè¿™æ ·åšä¹‹åï¼Œæˆ‘ä»¬è¿”å›çš„å·²ç»æ˜¯æ›´æ–°è¿‡çš„ stateã€‚

```js focus=195:198
function createDom(fiber) {
  const dom =
    fiber.type == "TEXT_ELEMENT"
      ? document.createTextNode("")
      : document.createElement(fiber.type)
â€‹
  const isProperty = key => key !== "children"
  Object.keys(fiber.props)
    .filter(isProperty)
    .forEach(name => {
      dom[name] = fiber.props[name]
    })
â€‹
  return dom
}

const isEvent = key => key.startsWith("on")
const isProperty = key => key !== "children"
const isNew = (prev, next) => key =>
  prev[key] !== next[key]
const isGone = (prev, next) => key => !(key in next)
function updateDom(dom, prevProps, nextProps) {
  //Remove old or changed event listeners
  Object.keys(prevProps)
    .filter(isEvent)
    .filter(
      key =>
        !(key in nextProps) ||
        isNew(prevProps, nextProps)(key)
    )
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.removeEventListener(
        eventType,
        prevProps[name]
      )
    })
â€‹
  // Remove old properties
  Object.keys(prevProps)
    .filter(isProperty)
    .filter(isGone(prevProps, nextProps))
    .forEach(name => {
      dom[name] = ""
    })
â€‹
  // Set new or changed properties
  Object.keys(nextProps)
    .filter(isProperty)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      dom[name] = nextProps[name]
    })

   // Add event listeners
  Object.keys(nextProps)
    .filter(isEvent)
    .filter(isNew(prevProps, nextProps))
    .forEach(name => {
      const eventType = name
        .toLowerCase()
        .substring(2)
      dom.addEventListener(
        eventType,
        nextProps[name]
      )
    })
}

function commitRoot() {
  deletions.forEach(commitWork)
  commitWork(wipRoot.child)
  currentRoot = wipRoot
  wipRoot = null
}
â€‹
function commitWork(fiber) {
   if (!fiber) {
    return
  }
  let domParentFiber = fiber.parent
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent
  }
  const domParent = domParentFiber.dom
â€‹
  if (
    fiber.effectTag === "PLACEMENT" &&
    fiber.dom != null
  ) {
    domParent.appendChild(fiber.dom)
  } else if (
    fiber.effectTag === "UPDATE" &&
    fiber.dom != null
  ) {
    updateDom(
      fiber.dom,
      fiber.alternate.props,
      fiber.props
    )
  } else if (fiber.effectTag === "DELETION") {
    commitDeletion(fiber, domParent)
  }
â€‹
  commitWork(fiber.child)
  commitWork(fiber.sibling)
}
â€‹
function commitDeletion(fiber, domParent) {
  if (fiber.dom) {
    domParent.removeChild(fiber.dom)
  } else {
    commitDeletion(fiber.child, domParent)
  }
}
â€‹
function render(element, container) {
  wipRoot = {
    dom: container,
    props: {
      children: [element],
    },
    alternate: currentRoot,
  }
  deletions = []
  nextUnitOfWork = wipRoot
}
â€‹
let nextUnitOfWork = null
let currentRoot = null
let wipRoot = null
let deletions = null
â€‹
function workLoop(deadline) {
  let shouldYield = false
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(
      nextUnitOfWork
    )
    shouldYield = deadline.timeRemaining() < 1
  }
â€‹
  if (!nextUnitOfWork && wipRoot) {
    commitRoot()
  }
â€‹
  requestIdleCallback(workLoop)
}
â€‹
requestIdleCallback(workLoop)
â€‹
function performUnitOfWork(fiber) {
  const isFunctionComponent =
    fiber.type instanceof Function
  if (isFunctionComponent) {
    updateFunctionComponent(fiber)
  } else {
    updateHostComponent(fiber)
  }
  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}
â€‹
let wipFiber = null
let hookIndex = null
â€‹
function updateFunctionComponent(fiber) {
  wipFiber = fiber
  hookIndex = 0
  wipFiber.hooks = []
  const children = [fiber.type(fiber.props)]
  reconcileChildren(fiber, children)
}

function useState(initial) {
  const oldHook =
    wipFiber.alternate &&
    wipFiber.alternate.hooks &&
    wipFiber.alternate.hooks[hookIndex]
   const hook = {
    state: oldHook ? oldHook.state : initial,
    queue: [],
   }

â€‹const actions = oldHook ? oldHook.queue : []
  actions.forEach(action => {
    hook.state = action(hook.state)
  })

  const setState = action => {
    hook.queue.push(action)
    wipRoot = {
      dom: currentRoot.dom,
      props: currentRoot.props,
      alternate: currentRoot,
    }
    nextUnitOfWork = wipRoot
    deletions = []
  }
â€‹
  wipFiber.hooks.push(hook)
  hookIndex++
  return [hook.state, setState]

}

function updateHostComponent(fiber) {
  if (!fiber.dom) {
    fiber.dom = createDom(fiber)
  }
  reconcileChildren(fiber, fiber.props.children)
}

function reconcileChildren(wipFiber, elements) {
let index = 0
  let oldFiber =
    wipFiber.alternate && wipFiber.alternate.child
  let prevSibling = null
â€‹
  while (
    index < elements.length ||
    oldFiber != null
  ) {
    const element = elements[index]
    let newFiber = null
â€‹
    const sameType =
      oldFiber &&
      element &&
      element.type == oldFiber.type
â€‹
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: "UPDATE",
      }
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: "PLACEMENT",
      }
    }

    if (oldFiber && !sameType) {
      oldFiber.effectTag = "DELETION"
      deletions.push(oldFiber)
    }
â€‹
    if (oldFiber) {
      oldFiber = oldFiber.sibling
    }

    if (index === 0) {
      fiber.child = newFiber
    } else {
      prevSibling.sibling = newFiber
    }

    prevSibling = newFiber
    index++
  }

  if (fiber.child) {
    return fiber.child
  }
  let nextFiber = fiber
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling
    }
    nextFiber = nextFiber.parent
  }
}

const Didact = {
  createElement,
  render,
  useState,
}
â€‹
/** @jsx Didact.createElement */
function Counter() {
  const [state, setState] = Didact.useState(1)
  return (
    <h1 onClick={() => setState(c => c + 1)}>
      Count: {state}
    </h1>
  )
}
const element = <Counter />
const container = document.getElementById("root")
Didact.render(element, container)
```

---

å°±æ˜¯è¿™æ ·ï¼Œæˆ‘ä»¬æ„å»ºäº†è‡ªå·±çš„ Reactã€‚

```js

```

---

å¯ä»¥åœ¨[codesandbox](https://codesandbox.io/s/didact-8-21ost)ä¸Šä½“éªŒå®Œæ•´çš„ä»£ç 

</CH.Scrollycoding>
